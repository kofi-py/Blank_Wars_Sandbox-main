#!/usr/bin/env ts-node
/**
 * Dynamic Type Generator
 * Generates TypeScript types from database enum values
 * NO FALLBACKS - fails if database is unavailable
 */

import { config } from 'dotenv';
import { Pool } from 'pg';
import * as fs from 'fs';
import * as path from 'path';

// Load environment variables from .env file
config({ path: path.join(__dirname, '../.env') });

const DATABASE_URL = process.env.DATABASE_URL;

if (!DATABASE_URL) {
  console.error('‚ùå DATABASE_URL environment variable is required');
  process.exit(1);
}

const pool = new Pool({ connectionString: DATABASE_URL });

interface TypeDefinition {
  name: string;
  query: string;
  column: string;
}

const TYPE_DEFINITIONS: TypeDefinition[] = [
  {
    name: 'Archetype',
    query: 'SELECT DISTINCT archetype FROM characters WHERE archetype IS NOT NULL ORDER BY archetype',
    column: 'archetype'
  },
  {
    name: 'Species',
    query: 'SELECT DISTINCT species FROM characters WHERE species IS NOT NULL ORDER BY species',
    column: 'species'
  },
  {
    name: 'CharacterRarity',
    query: 'SELECT DISTINCT rarity FROM characters WHERE rarity IS NOT NULL ORDER BY rarity',
    column: 'rarity'
  },
  {
    name: 'PowerTier',
    query: 'SELECT DISTINCT tier FROM power_definitions WHERE tier IS NOT NULL ORDER BY tier',
    column: 'tier'
  },
  {
    name: 'SpellTier',
    query: 'SELECT DISTINCT tier FROM spell_definitions WHERE tier IS NOT NULL ORDER BY tier',
    column: 'tier'
  }
];

async function generateTypes(): Promise<void> {
  console.log('üîß Generating TypeScript types from database...');

  try {
    // Test database connection
    await pool.query('SELECT 1');
    console.log('‚úÖ Database connection established');

    const generatedTypes: string[] = [
      '// AUTO-GENERATED FILE - DO NOT EDIT',
      '// Generated by scripts/generate-types.ts',
      '// Run `npm run generate-types` to regenerate',
      '',
      '// This file is generated from the database schema',
      '// If the database is unavailable, the build will fail (no fallbacks)',
      ''
    ];

    // Generate each type
    for (const typeDef of TYPE_DEFINITIONS) {
      console.log(`  Generating ${typeDef.name}...`);

      const result = await pool.query(typeDef.query);

      if (result.rows.length === 0) {
        throw new Error(`No values found for ${typeDef.name} - query returned empty result`);
      }

      const values = result.rows
        .map(row => row[typeDef.column])
        .filter(val => val !== null && val !== undefined)
        .map(val => `'${val}'`)
        .join(' | ');

      generatedTypes.push(`export type ${typeDef.name} = ${values};`);
      generatedTypes.push('');

      console.log(`  ‚úÖ ${typeDef.name}: ${result.rows.length} values`);
    }

    // Write to file
    const outputPath = path.join(__dirname, '../src/types/generated.ts');
    fs.writeFileSync(outputPath, generatedTypes.join('\n'));

    console.log(`‚úÖ Types generated successfully: ${outputPath}`);

  } catch (error) {
    console.error('‚ùå Type generation failed:', error);
    throw error;
  } finally {
    await pool.end();
  }
}

// Run
generateTypes()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
